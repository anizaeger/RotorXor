/********************************************************************************
 *                                                                              *
 * Copyright (C) 2018 by Anakin-Marc Zaeger                                     *
 * All Rights Reserved                                                          *
 *                                                                              *
 * This file is part of RotorXor.                                               *
 *                                                                              *
 * RotorXor is free software: you can redistribute it and/or modify             *
 * it under the terms of the GNU General Public License as published by         *
 * the Free Software Foundation, either version 3 of the License, or            *
 * (at your option) any later version.                                          *
 *                                                                              *
 * RotorXor is distributed in the hope that it will be useful,                  *
 * but WITHOUT ANY WARRANTY; without even the implied warranty                  *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                *
 * GNU General Public License for more details.                                 *
 *                                                                              *
 * You should have received a copy of the GNU General Public License            *
 * along with RotorXor.  If not, see <http://www.gnu.org/licenses/>.            *
 *                                                                              *
 ********************************************************************************/
/**
 * @file
 * @author Anakin-Marc Zaeger
 *
 * @brief Source file for Xorer class.
 *
 */
#include "xorer.hh"

#include <algorithm>

#include <iostream>

using namespace RotorXor;

/// Keys for the CSPRNG.
typedef KeyFile::Key Key;

/// Vector of pointers to keys in the primary keychain.
typedef std::vector< Key* > KeyVec;

Xorer::Xorer( int numRotors )
{
	scrambler = new Scrambler( numRotors );
	pulser = new Pulser( numRotors );
}

/**
 * Initializes the scrambler and pulser with keys provided from the primary keychain.
 *
 * @param keyVec A vector containing pointers to keys within the primary keychain.
 */
void
Xorer::setKeys( KeyVec& keyVec )
{
	int halfSize = keyVec.size() / 2;
	KeyVec sKeys;
	KeyVec pKeys;
	Key* keyPtr = nullptr;

	for ( int key = 0; key < keyVec.size(); key++ )
	{
		keyPtr = keyVec[ key ];
		if ( key < halfSize )
		{
			sKeys.push_back( keyPtr );
		}
		else
		{
			pKeys.push_back( keyPtr );
		}
	}

	if ( sKeys.size() > 1 )
	{
		std::reverse( sKeys.begin(), sKeys.end() - 1 );
	}

	if ( pKeys.size() > 1 )
	{
		std::reverse( pKeys.begin(), pKeys.end() - 1 );
	}

	if ( scrambler )
	{
		delete scrambler;
		scrambler = nullptr;
	}
	scrambler = new Scrambler( sKeys );

	if ( pulser )
	{
		delete pulser;
		pulser = nullptr;
	}
	pulser = new Pulser( pKeys );
}

/**
 * Accepts a character for translation.  The Xorer will use the scrambler to generate an
 * XOR character, XOR that character with inChar, and return the result.
 *
 * @param inChar The character to be encoded.
 * @return The encoded character.
 */
char
Xorer::encode( char inChar )
{
	try
	{
		char xorChar = 0;
		char outChar = 0;
		xorChar = scrambler->genChar();
		outChar = calc( inChar, xorChar );
		return outChar;
	}
	catch( ... )
	{
		throw;
	}
}

/**
 * Randomly, yet deterministically, step the Xorer's scrambler rotor.
 */
void
Xorer::step()
{
	/// The pulser generates, at most, 1 less pulse than there are number of rotors in the scrambler.
	int numSteps  = scrambler->numRotors() - 1;

	/// A pulse vector for the scrambler is generated by the pulser.
	std::vector< bool > stepVec = pulser->pulse( numSteps );

	/// This vector is passed to scrambler, which steps the indicated rotors.
	scrambler->step( stepVec );
}
